A component declares the DOM a component should render. Declare is the word,
you don't work on the DOM in an imperative way: you say what you want, React makes it work for you.

A component can render other components or directly HTML elements (see react-native that render native code).
A component is a function, so an HTML element needs to be one too. They work the same way, they can be nested
and configured (a component takes props, as an HTML element does <input value="awesome" />).

Calling functions with props, children and stuff works well, but not that readable (purely subjective).
There's a lot of way to make it, React.createElement, hyperscript, or simply, JSX.


// TODO investigate if not better to start with this section (before intro)
FAKE SEPARATION OF CONCERNS
Template in the logic > logic in the Template
    You get a real language (JavaScript for the better and the worse), linter, static types, reusable logic, etc.
    Angular templates (and others) are just weird DSLs to do stuff that you can do in JS
Separating technologies is not separating concerns.
    // https://www.youtube.com/watch?v=x7cQ3mrcKaY
    You want to decoupled your views from your data management, your UI from your domain, HTML/JS
    You'll actually see that often with this separation you'll have to duplicate value/logic
        e.g. values defined in CSS and JS (colours, see vamos themes), or both your template and logic having an impact on your template

COMPOSITION
// https://www.youtube.com/watch?v=wfMtDGfHWpA
No need for inheritance => the gorilla and the banana problem
Composition is what something does, more than what it is.
Compose several functions together to create more powerfull/specialised ones (remember, a component is a function)
Example

LET'S DIG IN
How to write JSX
It's just a JS function call. Once you realise that, how to do stuff, what you can do gets logical
    evaluating a value => {}
    conditional => ternary (or bool && val)
    loop => Iterable.map
    partials => function calls/other component
    html props are a bit different => some exceptions (className) and camelCase
    bool default to true
Example
    gotcha: bind this when passing function to other component (context changes, for instance events) `examples/bind`
Example

Component API
this.setState   => how it works. It's about render, not used in render, does not belong in the state
defaultProps    can be found on functional components
propTypes    can be found on functional components
lifecycle   => parent's state is kept => lift the state up
children as a prop    can be found on functional components and be passed as a "normal" prop

TODO
    controlled/uncontrolled form?
